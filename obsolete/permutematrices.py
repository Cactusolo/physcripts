#!/usr/bin/env python
#
#  permute_matrix.py
#  
#
#  Created by Cody on 2/9/11.
#
#

#######################################################################################
#
#	permute_matrix.py
#
#	Requires arguments, to be passed via the command line, in order: 
#		
#		- Path to a CSV file containing sampling information, with rows corresponding
#		  to taxa and columns to loci. Each cell in the CSV matrix should contain
#		  either a '-', correspdonding to a missing sequence, or an 'X' or 'x'
#		  correspond to a non-missing sequence. The first row and first column of this
#		  file should contain the labels for the loci and taxa, respectively. 
#
#		- Height of the sampling matrix in cells (i.e. number of taxa)
#
#		- Width of the sampling matrix in cells (i.e. number of loci)
#
#	This script will calculate all the possible sampling matrices that could be
#	generated by further sampling on the provided reference matrix (the CSV file).
#

######## gather modules

import numpy as np
import copy
import sys
import csv

######## class definitions

class smatrix(np.ndarray):
	nseqs_added = 0
	nseqs_initial = 0


######## function definitions

def permute(list_matrices_to_permute, list_mutable_cell_indices, max_cells_to_fill = -1):

	"""permute() recursively calculates all the possible permutations """ \
	"""of each matrix in a list of 2-dimensional boolean matrices, """ \
	"""given a list of cells available to permute."""

	# starting new round of permutations
	matrices = list_matrices_to_permute
	cells = list_mutable_cell_indices

	ncurcells = len(cells)
	# if we haven't already permuted every cell
	if len(cells) > 0:
		c = cells.pop()
#		if ncurcells % 100 == 0:
		print "Current cell: " + str(ncurcells)
		
		# make a copy of the current set of matrices
		for matrix in copy.copy(matrices):
			
			# change the value of the active cell for each matrix in the current set
			matrix_mut = copy.copy(matrix)

			if matrix_mut[c] == True:
				matrix_mut[c] = False
			else:
				matrix_mut[c] = True
			
			# how many addl. sequences are required to create this sampling matrix 
			matrix.nseqs_added = matrix.sum() - matrix.nseqs_initial
			
			if max_cells_to_fill <= matrix.nseqs_added:
				# append the mutated matrix to the set of all permutations
				matrices.append(matrix_mut)

		# recur to permute the next cell on all saved matrices
		permute(matrices,cells)
	
	# we're done. return a list containing all the permuted matrices
	return matrices


######## main operating code

# collect arguments from the command line
try:
	csv_file = open(sys.argv[1], "rb")
	csv_matrix = csv.reader(csv_file)
	
	# we require the user to specify height and width of the reference matrix
	# so we don't accidentally grab empty rows/cols from csv file
	h = int(sys.argv[2])
	w = int(sys.argv[3])

except ValueError:
	exit("\nThe arguments could not be converted into integers.\n")
except IOError:
	exit("\nThe file path could not be opened.\n")
except IndexError:
	exit("\nUsage:\n" \
		 ">python decisiveness.py <sampling_matrix.csv> <height> <width>")

# initialize an empty matrix to hold the original sampling data for reference
refmatrix = smatrix((h,w), dtype=bool)

# extract data from the csv file
data = [row for row in csv_matrix]

print "\nRaw sampling data from %s:" % sys.argv[1]
for line in data:
	print line

# collect column and row headers from the csv file
loci = [val.strip() for val in data[0][1:w+1]]
taxa = [row[0] for row in data[1:h+1]]

print "\nLocus labels:"
print loci

print "\nTaxon labels:"
print taxa

# iterate over cells from the csv file and populate the reference matrix
for r in range(1,h+1):
	for c in range(1,w+1):
		d = data[r][c]

		if d == '-':
			val = False
		elif d == 'X' or d == 'x':
			val = True
		else:
			exit("Illegal character in cell corresponding to (%s, %s) in reference matrix." % (taxa[r], loci[c]))

		refmatrix[r-1][c-1] = val

#print "\n\nTESTING: 8 x 8 matrix!\n\n"
#refmatrix = smatrix((8,8), dtype=bool)
#print refmatrix

refmatrix.nseqs_initial = refmatrix.sum()

print "\nReference matrix for permutation, containing %i initial sequences:" % refmatrix.nseqs_initial
print refmatrix

# generate a list containing references to all unsampled cells in the reference matrix
cells = list()
col = 0
row = 0
while col < refmatrix.shape[0]:
	while row < refmatrix.shape[1]:
		if refmatrix[col,row] == False:
			cells.append((col,row))
		row += 1
	col += 1
	row = 0

# calculate all permutations possible by adding data to the original sampling matrix
permutations = permute([refmatrix],cells)

print "Found %i permutations." % len(permutations)
#print permutations
